# JAVA 알고리즘 정리 2

## Heap과 Graph

# Heap

 &#9989; <https://kingpodo.tistory.com/30?category=805745> 

> 힙은 각 노드의 키 값이 그 자식의 키 값보다 작지 않은 완전 이진 트리이다. 이것을 최대 힙이라고 한다.  또한 힙을 각 노드의 키 값이 그 자식의 키값보다 크지 않은 완전 이진 트리로 정의하기도 하는데 이것을 최소 힙이라고 한다. 

1. 힙에서의 삽입

   삽입해야 하는 노드의 키 값을 부모노드와 비교하여 위치를 변경하여 최대 힙 또는 최소 힙 형태를 만들어야 합니다.

   ```java
   public static void insertHeap(int[] heap, int size, int item) {
       // heap의 배열과 size는 현 heap의 원소의 개수, item은 삽입 원소
       if(size == heap.length-1) {
           // 힙이 만원이 상태라면 종료
           System.out.println("Heap size 초과");
           return;
       }
       int i = ++size; 
       // 다음 item이 들어갈 원소 위치
       while(true) {
           if(i==1) {break;}
           // 힙의 원소가 하나도 없었따면 반복문 탈출
           if(item < heap[i/2]) {break;}
           // 아이템이 부모 노드보다 작다면 반복문 탈출
           heap[i] = heap[i/2];
           // 부모노드의 키 값을 자식노드로 이동
           i /= 2;
           // i의 위치를 즉 원소가 들어갈 자리를 부모노드로 변경
       }
       heap i] = item;
       // 정해진 i위치에 item삽입
   }
   ```



2. 힙에서의 삭제

   힙에서 원소의 삭제는 루트의 있는 원소를 제거하고 나머지 트리가 다시 힙이 되도록 재조정해야 합니다.

   ```java
   public static int deleteHeap(int[] heap, int size) {
       // 힙으로부터 원소 삭제
       int n = size;
       // Heap안에 있는 마지막 원소의 다음 위치
       if(n == 0) {return 999;}
       // 삭제할 원소가 없다면 에러
       int item = heap[1]; // 삭제 노드를 item에 저장
       int temp = heap[n]; // 마지막 원소를 temp에 저장
       
       n--; // 마지막 원소의 삭제
       int i = 1;
       // 원소를 가르키는 변수 최초는 삭제하는 루트
       int j = 2;
       // j변수는 i변수의 왼쪽 서브트리를 가르키는 변수
       while(j <= n) {
           // 서브트리의 위치가 현 원소의 수보다 커진다면 힙의 크기를 초과하니까 종료
           if(j = heap[j]) {
               // temp가 현 서브트리보다 크다는 것은 현 i위치가 원소의 위치가 맞다는 것이다.
               break;
           }
           heap[i] = heap[j];
           // 서브트리를 한 레벨 위로 이동
           i = j; // 비교할 노드의 위치를 바꿔줌
           j *= 2; // j의 서브트리 위치를 이동한다.
       }
       heap[i] = temp; // 마지막 원소를 i위치에 넣어준다.
       return item;
   }
   ```

   

3. 완전 이진트리 힙으로 만들기

   힙으로 되어있지 않은 완전 이진트리를 힙으로 변환하기 위해서는 역 레벨 순서로 힙의 내부 노드 각각을 루트 노드로 하는 서브트리를 차례대로 힙으로 만들면 된다.

   ```java
   public static void makeHeap(int[] bt, int size) {
       // 완전 이진트리를 Heap형태로 만든다.
       // bt는 Heap이 아닌 완전 이진 트리(binary tree), size는 원소의 개수
       for(int i=size/2; i>=1; i--) {
           // 서브트리가 있는 마지막 노드, 레벨순서의 역으로 시작
           int p=i;
           // 선택된 노드의 번호를 저장
           for(int j=2*p; j<=size; j*=2) {
               // j는 p노드의 왼쪽 서브트리를 가리킨다.
               // j는 전체 트리보다 커질 수 없고 증감식에서는 다음 서브트리를 가리킨다.
               if(j < size) {
                   // j의 부모노드가 오른쪽 자식 노드가 없는지 있는지 검사! 있다면
                   if(bt[j] < bt[j+1]) {
                       // 두 서브트리를 비교하여 큰 것을 선택
                       j++;
                   }
               }
               if(bt[p] < bt[j]) {break;}
               // 현 노드가 서브노드부터 크다면 다음레벨로 이동
               int temp = bt[p]; // 그것이 아니라면 둘을 교환
               bt[p] = bt[j];
               bt[j] = temp;
               p = j; // 부모 노드를 한 레벨 밑으로 이동
           }
       }
   }
   ```



### 그래프(graph)

&#9989; <https://kingpodo.tistory.com/45?category=805745>

> 그래프는 G=(V,E)로 정의된다. 여기서 V는 공백이 아닌 노드 또는 정점의 유한 집합으로 정점만을  표현할 때는 V(G)라고 표기. E는 상이한 두 정점을 잇는 간선의 유한 집합으로 간선만을 표현할 때는 E(G)라 표기합니다.

 1. 방향그래프, 무방향그래프

    * 무방향 그래프: 간선을 표현하는 두 정점의 쌍에 순서 즉 방향이 없는 그래프입니다. 따라서 두 정점 V0과 V1을 잇는 간선 (V0, V1)과 (V1, V0)는 똑같은 간선을 나나타낸다.
    * 방향 그래프: 모든 간선을 순서가 있는 두 정점의 쌍으로 표현하는 즉, 간선이 방향을 가진 그래프입니다. 방향 그래프에서는 하나의 간선을 V0 -> V1을 <V0, V1>이라 표기하며 V0를 tail, V1를 Head라 합니다. 또한 방향 그래프에서는 <V0, V1>과 <V1, V0>는 다른 간선입니다. 방향 그래프에서는 이 간선을 아크라고도 합니다.

    

	2.  완전 그래프

    간선을 최대한으로 가진 그래프를 말한다. n개의 정점을 가진 무방향 그래프의 최대 간선 수는 n(n-1)/2입니다. 그러나 n개의 정점을 가진 방향 그래프의 최대 간선은 n(n-1)개가 됩니다.

    

	3. 인접과 부속

    * 인접: 간선 (V0, V1)가 무방향 그래프 G의 간선일 때 노드 V0와 V1은 서로 인접한다고 합니다.
    * 부속: 간선 (V0, V1)가 무방향 그래프 G의 간선일떄 간선 (V0, V1)은 정점 V0와 V1의 부속이 된다고 합니다.

    

	4. 부분 그래프

	5. 경로

	6. 사이클

    첫번째 지점과 마지막 정점이 동일한 단순 경로를 말한다. 따라서 무방향 그래프에서는 사이클의 길이는 항상 3이상이고 방향 그래프에서 사이클의 길이는 항상 2이상이다. 또한 이러한 사이클이 없는 그래프를 DAG(Directed Acyclic Graph)라고 한다.



7. 강한 연결, 약한 연결

   방향 그래프 G에서 V(G)에 있는 서로 다른 모든 정점의 쌍 u와 v에 대해 u에서 v까지의 방향 경로와 v에서 u까지의 방향경로가 있을 때 `강한 연결`이라고 한다. 만일 이때 u에서 v까지나 v에서 u까지 어느 하나의 경로만 있다면 `약한 연결`이다.



8. 차수

   * 정점의 차수는 그래프에서 그 정점에 부속된 간선의 수를 말한다.
   * 진입 차수: 만약 그래프가 방향 그래프라면 정점 v의 진입 차수는 정점 v를 head로 하는 아크의 수를 말합니다.
   * 진출 차수: 만약 그래프가 방향 그래프라면 정점 v의 진출 차수는 정점 v를 tail로 하는 아크의 수를 말합니다.

   아래 그래프 a의 정점 V0의 차수는 3이며 그래프 b의 정점 V0의 진입 차수는 2, 진출 차수는 3입니다.



### 그래프의 표현(인접 행렬, 인접 리스트, 인접 다중 리스트)

&#9989; <https://kingpodo.tistory.com/46?category=805745>

> 그래프를 표현하는 방법은 여러가지가 있지만 그 중 대표적인 방법이 인접행렬, 인접 리스트, 인접 다중 리스트이다. 이때 어떤 표현 방법을 선택하느냐 하는 것은 그래프에 수행시키려는 연산과 이용하려는 응용에 달려 있다고 하겠다.

1. 인접 행렬

   그래프 G=(V,E)를 n >= 1(n은 정점의 수)의 정점이 가진 그래프라고 하였을 때, 그래프 G에 대한 인접행렬의 크기는 n*n이며 a[n,n]크기의 2차원 배열로 표현된다. 이때 a[n,n]에서 a[i,j] ∈ E(G)라면 1값을 아니라면 0의 값을 가지게 된다.

   무방향 그래프의 경우 인접행렬은 간선간의 특성상 대칭이 된다.

   방향 그래프는 인접행렬의 표현 방식에서 진입 차수와 진출 차수는 a[i,j] ∈ E(G)의 경우에 i 행의 합을 구하면 진출 차수이고 i 열의 합을 구하면 진입 차수이다.

   

2. 인접 리스트

   인접 리스트로 그래프를 표현하는 방법은 n개의 정점을 각각에 대해 인접한 정점들의 리스트로 만드는 것이다. 그러기 위해서는 아래 그림과 같이 리스트의 노드 구조를 정점필드와 주소필드로 구성하여야 한다. 그래야만 어떤 정점 i에 대한 인접 리스트에 정점 i와 인접한 정점들을 나타내는 노드들을 포함시키게 할 수 있다.

   아래와 같은 방식을 정점 n개와 간선 e개를 가진 무방향 그래프의 경우 n개의 헤더 노드와 2*e개의 리스트 노드가 필요하게 된다. 그리고 각 리스트 노드는 link필드를 가지게 된다. 그러나 포인터를 사용하지 않고 인접 리스트의 노드를 순차적으로 묶어서 저장하는 방법도 있다. 이 경우 
# B형 3번

| 제한 조건      | 실행시간 : 최대 50개의 테스트 케이스를 합쳐서 10초 이내 메 모 리 : Heap, Global, Stack 등을 모두 합해 최대 512MB까지 사용 가능 (단, 스택은 최대 1MB까지 사용 가능) |
| -------------- | ------------------------------------------------------------ |
| 제출 횟수 제한 | 20회                                                         |
| 채점           | 답안을 제출하면 제공된 sample_input.txt 에 대한 결과를 판정해서 실시간으로 알려주며 그 의미는 다음과 같다. **Accept** **: sample input****에 대하여 정답 또는 부분 점수 획득** **Fail** **: sample input****에 대하여 오답 또는 런타임 에러, time out 등** (※ sample_input.txt 파일 다운로드는 문제 지문 바로 아래에 있습니다) 최종결과는 별도의 채점용 input으로 진행되므로 시험 중 판정 결과와 다를 수 있다. |
| 평가           | 최종 점수는 별도로 제작된 평가용 테스트 케이스로 측정하며, 동점자간에는 실행시간에 따라 점수 차이가 발생할 수 있습니다. 따라서 시험이 끝날 때까지 본인의 코드를 최적화 하시기를 권장합니다. |

 

 

 

**[****코드 작성 시 주의점]**

 

**① C** **또는 C++로 답안을 작성하시는 응시자께서는 검정시스템에 제출 시, Language에서 C++를** **선택하신 후 제출해 주시기를 바랍니다.**

 

**② Main** **부분과 User Code 부분으로 구성되어 있습니다.**

 

A. Main 부분 : 수정할 수 없는 코드이며, 채점 시 주어지는 코드 그대로 사용됩니다.

 

B. User Code 부분 : 실제 응시자가 작성해야 하는 코드이며, 제출 시에는 코드 내에

 

​                   라이브러리 함수뿐 아니라 표준 입출력 함수도 포함되어서는 안됩니다.


                         (단, C/C++의 경우 malloc.h는 사용 가능.)

 

C. 서버에서 Main 부분과 User Code 부분은 별도의 파일로 분리되어 컴파일이 됩니다.

 

   (main.cpp /solution.cpp 또는 Solution.java/UserSolution.java)

 

**③ Local PC****에서 프로그래밍할 시 유의 사항**

 

A. 2개의 파일을 생성하셔야 합니다. (main.cpp/solution.cpp 또는 Solution.java/UserSolution.java)

 

B. Main 부분의 코드를 main.cpp 또는 Solution.java에 복사해서 사용하시기 바랍니다.

 

C. sample_input.txt를 사용하시기 위해서는 Main 부분의 코드 내에 표준 입력을 파일로 전환하는 코드(주석처리 되어 있음)의 주석을 풀어서 사용하시면 됩니다.

 

D. User Code 부분의 코드를 작성하신 후 서버에 제출하실 때, 디버깅을 위한 라이브러리 함수뿐 아니라 표준 입출력 함수를 모두 삭제 또는 주석 처리해 주셔야 합니다.

 

**④** **문제 내에 제약조건을 모두 명시하지 않으므로 주어지는 코드를 분석하셔야 합니다.**

 

**⑤** **코드는 개발 언어에 따라 상이할 수 있으므로, 작성할 언어를 기준으로 분석하셔야 합니다.**

 

 

**[문제설명]**

 

디스크 접근을 위한 스케줄링을 구현한다.

 

스케줄링에 따른 Track 처리 순서는 아래와 같다.


\1. **FCFS** (First Come First Served) : 요청된 순서대로 처리한다.


\2. **SSTF** (Shortest Seek Time First) : 현재 Head 위치를 기준으로 탐색 거리가 가장 짧은 요청을 먼저 처리한다. 가능한 Track이 2개인 경우, 좌측(번호가 작은) track 을 먼저 처리한다.


\3. **LOOK** : Head 의 진행방향 중 가장 짧은 거리의 요청을 먼저 처리한다. 
   현재 진행방향에서 더 이상 처리할 것이 없는 경우 방향을 반대로 전환한다.
   초기 진행방향은 좌측 방향이다. (track 번호가 작아지는 방향)


\4. **C-LOOK** : LOOK 과 마찬가지로 Head 의 진행방향 중 가장 짧은 거리의 요청을 먼저 처리한다. 

   LOOK과의 차이점은 진행방향이 좌측으로 고정이고, 더 이상 처리할 것이 없는 경우 Head 가 우측 끝으로 돌아가서 가장 우측에 있는 track 을 처리한다.

 

Head 는 처리할 Track 의 위치로 이동한다.


LOOK 의 Head 진행 방향은 다른 스케줄링 방식에 영향을 받지 않는다.

 

[Fig. 1]은 Track 사이즈가 200, Head의 초기 위치 60, 요청 순서가 98, 183, 37, 122, 14, 124, 65, 67 일 때 각 스케줄링 방식의 Head의 움직임과 처리순서를 나타낸다.

 

![](C:\Users\multicampus\Desktop\image\3번1.PNG)



\1. FCFS : 98, 183, 37, 122, 14, 124, 65, 67


\2. SSTF : 65, 67, 37, 14, 98, 122, 124, 183


\3. LOOK : 37, 14, 65, 67, 98, 122, 124, 183


\4. C-LOOK : 37, 14, 183, 124, 122, 98, 67, 65

 

LOOK 의 경우, 좌측 마지막 14번 Track 을 처리한 이후 Head 의 진행방향이 우측방향으로 변하였다.

 

C-LOOK 의 경우, 좌측 마지막 14번 Track 을 처리한 이후 가장 우측 183번 Track 을 처리한다.

 

[Fig. 1] 은 스케줄링 방식에 대한 이해를 돕기 위해 모든 요청이 완료된 후, 한 가지 방식으로만 처리하는 예제를 보인 것이다.

 

실제 Input 에서는 처리하는 중간 과정에서 새로운 요청이 발생할 수 있고, 4가지 방식이 무작위로 호출된다.

 

아래 API 설명을 참조하여 각 함수를 구현하라.

 

| **void** **init(int track_size, int head)**                  |
| ------------------------------------------------------------ |
| 각 테스트케이스의 처음에 호출된다. **Parameters**    track_size : Track의 크기, 실제로 호출되는 Track 번호는 0 ~ track_size-1 이다.     head : Head 의 초기 위치 |
| **void** **request(int track)**                              |
| 새로운 Track 을 요청한다. **Parameters**    track : 요청된 Track 번호 |
| **int** **fcfs()**                                           |
| 현재까지 요청된 Track 리스트 중에서 FCFS 방식으로 Track 하나를 처리하고, 그 번호를 리턴한다.  **Returns**    FCFS 방식으로 처리되는 Track 번호 |
| **int** **sstf()**                                           |
| 현재까지 요청된 Track 리스트 중에서 SSTF 방식으로 Track 하나를 처리하고, 그 번호를 리턴한다.  **Returns**    SSTF 방식으로 처리되는 Track 번호 |
| **int** **look()**                                           |
| 현재까지 요청된 Track 리스트 중에서 LOOK 방식으로 Track 하나를 처리하고, 그 번호를 리턴한다.  **Returns**    LOOK 방식으로 처리되는 Track 번호 |
| **int** **clook()**                                          |
| 현재까지 요청된 Track 리스트 중에서 C-LOOK 방식으로 Track 하나를 처리하고, 그 번호를 리턴한다.  **Returns**    C-LOOK 방식으로 처리되는 Track 번호 |

 

 

**[제약사항]**

 

\1. Track 의 크기 track_size 는 200 이상 100,000 이하의 정수이다. (200 ≤ track_size ≤ 100,000)

 

\2. Head 의 초기값은 0 이상 track_size 미만의 정수이다. (0 ≤ head < track_size)

 

\3. 요청되는 Track 번호는 0 이상 track_size 미만의 정수이다. (0 ≤ track < track_size)

 

\4. 같은 Track 번호는 두 번 이상 요청되지 않는다.

 

\5. Request 함수는 최대 track_size 번 호출된다.

 

\6. 4 가지 스케줄링 함수는 처리할 Track 이 있는 경우에만 호출된다.

 

\7. LOOK 의 진행방향은 look() 함수에 의해서만 변경된다.
 (이전 다른 함수 fcfs, sstf, clook에 의한 Head의 진행방향과 무관하다.)

 

\8. 발생할 수 있는 가장 짧은 거리는 0 이다.


\9. 제약사항을 벗어나는 입력은 주어지지 않는다.

 

 

**[입출력]**

입출력은 제공되는 Main 부분의 코드에서 처리하므로 User Code 부분의 코드에서는 별도로 입출력을 처리하지 않는다.

Sample inut에 대한 정답 출력 결과는 아래와 같은 형태로 보여진다.




# JAVA 알고리즘 정리 5

## Sort1

### Sort(정렬)

<https://new93helloworld.tistory.com/103?category=691027>

![](https://t1.daumcdn.net/cfile/tistory/2311B244591BA16314)

컴퓨터 알고리즘에 있어서 가장 기본적인 정렬 알고리즘이다.

1. #### 선택정렬

   ![](https://t1.daumcdn.net/cfile/tistory/264E3144591BA1600B)

   이중에서 가장 큰 값을 찾는다. 그 후에 가장 큰 값과 맨 마지막 값의 자리를 바꾼다. 그럼 결과적으로 가장 큰 값이 맨 끝자리로 오게 된다.

   그렇다면 마지막 값에 대해서는 더 이상 신경쓰지 않아도 된다. 이후에 남아있는 4개의 데이터에 대해서 다시 가장 큰 값을 찾아 4번째 위치에 있는 값과 자리를 바꿔준다.

   ```java
   selectionSort(A[], n) {
       for last <- downto 2{
           A[1...last] 중 가장 큰수 A[k]를 찾는다.
           A[k] <-> A[last]; A[k]와 A[last]값을 교환
       }
   }
   ```

   슈도코드로 선택정렬을 나타내면 위와 같다.

   시간 복잡도를 계산하면

   T(n) = (n-1) + (n-2) + ... + 2 + 1 = n(n-1) / 2 = O(n^2)

2. #### 버블정렬

   ![](https://t1.daumcdn.net/cfile/tistory/240D3244591BA16114)

   다음으로는 선택정렬과 기본 개념이 비슷한 버블정렬이다. 즉, 버블 정렬에서도 역시 정렬할 데이터 중 가장 큰 값을 찾아 그것을 맨 마지막자리로 옮겨온 후에 그 데이터는 잊어버리고 나머지 데이터에 대해 같은 작업을 반복한다는 것이다.

   다만, 최대값을 찾아서 그 최대값을 맨 마지막으로 가져오는 세부적인 방법에 대해서 선택정렬과 차이를 보인다.

   ```java
   bubbleSort(A[], n) {
       for last <- downto 2 {
           for i <- 1 to last - 1 {
               if(A[i] > A[i+1]) then A[i] <-> A[i+1] // 교환
           }
       }
   }
   ```

   다음은 슈도 코드로 표현된 버블 정렬이다.

   시간 복잡도는 다음과 같다.

   `T(n) = (n-1) + (n-2) + ... + 2 + 1 = O(n^2)`

3. #### 삽입정렬

   ![](https://t1.daumcdn.net/cfile/tistory/26086944591BA1621E)

   마지막으로 살펴볼 정렬 알고리즘은 `삽입 정렬`로 위의 두 알고리즘과 약간의 차이를 보인다.

   우리가 정렬할 데이터가 6개라면 첫번째 데이터는 데이터가 한개 이므로 그 자체로 정렬되어 있다고 볼 수 있다. 거기에 두번째 데이터를 추가해서 두개의 데이터가 정렬된 상태로 만들어 주는 것이다.

    ![](https://t1.daumcdn.net/cfile/tistory/2505E044591BA16204)

   위의 그림은 삽입정렬이 진행되고 있는 임의의 한 페이즈를 나타낸다. 현재 인덱스의 변수값이 4라고 했을 때 앞쪽의 데이터들은 정렬되어있다고 가정한다. 추가할 데이터 4는 tmp변수에 넣어놓고, 앞쪽의 데이터와 비교하고 앞쪽의 데이터가 크다면 그 데이터를 뒤로 이동시킨다. 만약 tmp안의 변수가 더 크다면 비교한 변수 뒤에 데이터 값을 넣어주게 된다.

   ```java
   insertionSort(A[], n) {
       for i <- 2 to n {
           A[1...i]의 적당한 자리에 A[i]를 삽입한다.
       }
   }
   ```

   슈도코드로 표현한 삽입정렬이다.

   시간 복잡도는 다음과 같다.

   `T(n) = (n-1) + (n-2) + ... + 2 + 1 = O(n^2)`

   ```java
   public static void sort(int[] array) {
       for(int i=1; i<array.length; i++) {
           int temp = array[i];
           int comp = i-1;
           while(comp >= 0 && array[comp] > temp) {
               array[comp+1] = array[comp];
               comp--;
           }
           array[comp+1] = temp;
       }
   }
   ```

   여기서 주목해야 할 점은 while문 내부의 `comp>=0`이다. 등호의 사용해야 배열에 같은 값이 있을 때 이 데이터를 바꾸지 않고 안정한 상태로 유지할 수 있다.



4. #### 합병정렬(Merge Sort)

   <https://new93helloworld.tistory.com/104?category=691027>

   합병정렬은 `분할정복법`이라는 알고리즘을 사용한다. 주어진 문제를 3단계에 걸쳐서 해결하는데 다음과 같다.

   1) 분할: 해결하고 하는 문제를 작은 크기의 동일한 문제로 분할한다.

   2) 정복: 각각의 작은 문제를 해결한다.

   3) 합병: 작은 문제의 해를 합하여 원래 문제에 대한 해를 구함

   분할의 예로써, 입력으로 n개의 데이터가 주어지고 최대값을 찾을 때 배열을 반으로 나누어서 앞쪽과 뒤쪽에서 최대값을 찾고 그 둘 중에 최대값을 찾아 비교하는 절차를 거쳤다. 전체 문제를 해결하는 방법을 각각의 분할된 영역에 그대로 적용할 수 있으므로 별도의 알고리즘이 필요없다.

   분할정복의 풀이는 본질적으로 Recursion의 풀이 방법이다.

   ![](https://t1.daumcdn.net/cfile/tistory/27703A3D591BA46A1D)

   먼저 적당히 데이터를 자르는 분할을 하고 이렇게 분할된 데이터를 재귀로 정렬한다.

   주의해야할 점은 n개의 데이터가 주어질 때 분할하기 위해 특별한 알고리즘이 필요한 것이 아니며 실제로 코딩해야할 것은 `merge`부분이다.

   ![](https://t1.daumcdn.net/cfile/tistory/245FC63D591BA46B24)

   분할을 반복하다보면 마지막은 길이가 하나인 리스트들로 나뉘어진다. 실제로 데이터들이 비교되고 자리를 바꾸는 것은 `merge`과정에서 일어난다. 왜냐면 길이가 1이되면 그 자체로 정렬된 상태이기 때문이다. 

   ![](https://t1.daumcdn.net/cfile/tistory/264F623D591BA46B2A)

   정렬된 2개의 리스트가 있을 때 어떻게 하나의 정렬된 리스트로 합병할 것인지 생각해보면, 길이가 n인 추가 배열을 만든 후에 길이가 n/2인 정렬된 2개의 리스트를 추가 배열에 합병하면 된다.

   단 여기서 주의점은 2개의 리스트가 각각 정렬되어있는 상태라는 ㅓㅅ이다. 이미 정렬이 되어있기 때문에 전체 10개의 값 중에서 가장 작은 값은 앞에서 첫번째거나 뒤쪽에서 첫번째가 가장 작은 값이 된다.

   따라서 병합하며 정렬을 하기 위해서는

   i인덱스에 있는 값과 j인덱스에 있는 값을 하나씩 비교한 후 추가배열에 저장하면 된다!

   ![](https://t1.daumcdn.net/cfile/tistory/2260943D591BA46C1E)

   i와 j의 값을 비교하면서 작은 값을 추가 배열에 하나씩 넣어주고 만약 해당 배열에 값이 추가 배열에 저장되었다면 i나 j의 값을 증가시켜 준다.

   ![](https://t1.daumcdn.net/cfile/tistory/217FF03D591BA46C21)

   마지막까지 실행되면 추가배열에 정렬된 상태로 합병된다. 이렇게해서 두개의 정렬된 배열을 merger해서 하나의 배열로 만들 수 있다.

   ```java
   mergeSort(A[], p, r) {
       if(p<r) then {
           q <- (p+r)/2;
           mergeSort(A, p, q);
           mergeSort(A, q+1, r);
           merge(A, p, q, r);
       }
   }
   
   merge(A[], p, q, r) {
       정렬되어 있는 배열 A[p...q]와 A[q+1...r]을 합하여 정렬된 하나는 배열 A[p...r]을 만든다.
   }
   ```

   MergeSort는 기본적으로 재귀함수이므로 매개변수를 명시적으로 생성한다. 위의 함수는 배열 A[] 인덱스 p에서 r까지 정렬하는 알고리즘이다. 따라서 모든 데이터를 정렬하기 위해서는 mergeSort(A[], 1, n)으로 호출하면 된다.

   Base case는 p >= r인데, 이 때는 데이터의 개수가 0개 또는 1개이므로 정렬할 필요가 없다. 따라서 p > r일때만 알고리즘이 동작한다.

   MergeSort 알고리즘은 기본적으로 분할정복이므로 중간 위치 인덱스를 q로 잡고 p와 r의 2분의 1지점을 구한다.

   이후에 앞쪽과 뒤쪽을 정렬하고 합치는데 합치는 과정은 merge라는 함수가 담당하게 된다.

   ```java
   void merge(int data[], int p, int q, int r) {
       int i=p, j=q+1, k = p;
       int tmp[data.length()];
       while(i<=q && j<=r) {
           if(data[i] <= data[j])
               tmp[k++] = data[i++];
           else
               tmp[k++] = data[j++];
       }
       while(i<=q)
           tmp[k++] = data[i++];
       while(j<=r)
           tmp[k++] = data[j++];
       for(int i=p; i<=r; i++) {
           data[i] = tmp[i];
       }
   }
   ```

   시작인덱스 p, 중간이 q, 마지막은 r일 때 `p ~ q`, `q+1 ~ r`까지는 이미 정렬되어있다는 가정을 할 때 이 전체를 합쳐서 하나의 배열로 만들어 주는 것이다. (tmp는 추가배열이다.) 또한 i, j, k도 설정해주는데 이는 위쪽 그림의 예시처럼 만들어 준다.

   첫번째 while문은 1차적으로 두 배열을 비교해서 정렬해주고, 두번째 while문은 앞쪽의 배열에 데이터가 남아있는 경우, 세번째 while문은 뒤쪽의 배열에 데이터가 남아있는 경우를 각각 처리해준다.

   마지막으로 추가 배열에 있는 값을 data배열 안에 저장해준다.
   ![](https://t1.daumcdn.net/cfile/tistory/2169A33D591BA46D29)

   다음으로 MergeSort의 시간 복잡도를 알아보자.

   재귀의 형태를 가지고 있지만 분할 정복법의 시간복잡도 계산을 반복문으로 처리한 계산보다 훨씬 쉽다.

   데이터가 n개일 때 T(n)이 걸린다고 한다면 반으로 쪼개서 n/2개의 배열에 재귀함수를 호출한다. 반으로 쪼개진 배열 2개에 대한 정렬을 수행하므로 `T([n/2]) + T([n/2])`의 시간이 걸린다.

   두개의 정렬된 배열을 merge할 때 두 배열을 한 번씩 비교하므로 merge의 시간은 n이다.

   따라서 MergeSort의 시간복잡도는 `T(n) = T([n/2]) + T([n/2]) = n`이 된다.

   ![](https://t1.daumcdn.net/cfile/tistory/254D423D591BA46E2A)

   이 순환식을 수학적으로 풀어보면 O(nlogn)이 된다.


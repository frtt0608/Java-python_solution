# JAVA 알고리즘 8

## Dynamic Programming

### 메모이제이션과 동적 계획법

1. #### 메모이제이션

   <https://new93helloworld.tistory.com/220?category=691027>

   > 메모이제이션은 보통 재귀와 같이 시간 복잡도가 큰 알고리즘에서 유용하다.
   >
   > JAVA 알고리즘3에서 설명했기 때문에 간단하게 리뷰만.

   피보나치, 팩토리얼과 같은 함수를 구현할 때 재귀를 사용하면서 계산시간을 줄이기위해 메모이제이션이라는 테크닉을 사용한다.

   이는 계산된 값을 버리지말고 저장한다는 뜻으로 필요할때마다 저장된 값을 사용하며 저장되는 배열을 `캐시`라고 한다.(중간에 저장하는 것을 `캐싱한다`라고 부른다.)

   ![](https://t1.daumcdn.net/cfile/tistory/262CD735593635962F)

2. #### Bottom up

   > 중복된 계산을 피하는 또 다른 방법으로 Bottom up이 있다. 재귀함수가 Top down임에 반해, Bottom p은 f(1)부터 f(n)까지 올라오는 것을 의미한다.
   >
   > 이 방식의 핵심은 아래부터 올라가기 때문에 f(n)을 구하기위해 f(n-1)과 f(n-2)을 계산해야 한다. 따라서 가장 기본적인 값으로 특정한 값을 계산하려고 하는 것을 Bottom up이라고 한다.

   이렇게 `Bottom up`방식으로 계산하는 테크닉을 `Dynamic Programming`이라고 한다. 물론, 이는 다이나믹 프로그래밍을 좁은 의미로 해석할 때 사용하는 방법이지만 가장 많이 사용되는 방법 중에 하나이기도 한다.

   ![](https://t1.daumcdn.net/cfile/tistory/2156E4395936467E1B)

   두번째 예로, `이항계수`를 구하는 알고리즘이다.

   이항 계수는 n개 중에 k개를 선택하는 경우의 수를 구할 때 사용한다.

   보통 `n!/(n-k)!*k!`로 계산을 하지만, 이렇게 할 경우 많은 계산이 중복된다. 또한 계산의 범위가 커질 경우 오버플로우가 생길 수도 있다. 그래서 위의 그림의 공식을 사용하도록 한다.

   물론, n=k일 때나 k=0일 때 1을 반환하도록 한다. 그래서 이를 계산할 때, 재귀코드를 사용해서 계산한다.

   ![](https://t1.daumcdn.net/cfile/tistory/2316FC435936477C01)

   그러나 이와 같은 재귀 계산에도 같은 값에 대해 중복되는 코드가 많아지므로 `메모이제이션`을 사용하면 훨씬 빠른 계산이 가능하다. 앞선 말한 것과 마찬가지로 -1로 모든 캐시 배열을 초기화해주며, -1일 경우 계산을 징행하고, 아닐 경우 해당 인덳의 배열 값을 호출한다.

   ![](https://t1.daumcdn.net/cfile/tistory/27646649593649AB34)

   마찬가지로 이를 `Bottom up`방식으로 계산하면 아래 그림처럼 나온다. 2차원 배열이라 어디가 Bottom up인지 생각할 수 있지만, Bottom up이란 위치가 바닥이 아닌 기본 값에서부터 시작한다는 뜻이된다.

   따라서, 순환식에서 기본 값을 토대로 계속 정답까지 구하므로 재귀가 필요없고 중복 값도 제거된다.

   ![](https://t1.daumcdn.net/cfile/tistory/26419E4D59364A611F)

3. #### Memoization vs. Dynamic Programming

   `Memoization`과 `Dynamic Programming`의 특징은 다음과 같다.

   1. `Memoization`과 `Dynamic Programming`은 둘다 순환식을 계산하는 방법이라고 할 수 있다.
   2. 모두 동적 계획법의 일종이라고 보기도 한다.
   3. `Memoization`은 Top down방식이고 실제 필요한 sub problem을 푼다.
   4. `Dynamic Programming`은 Bottom up방식이며 재귀에 수반되는 overhead가 없다.
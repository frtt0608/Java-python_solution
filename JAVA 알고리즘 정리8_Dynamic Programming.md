# JAVA 알고리즘 8

## Dynamic Programming

### 메모이제이션과 동적 계획법

1. #### 메모이제이션

   <https://new93helloworld.tistory.com/220?category=691027>

   > 메모이제이션은 보통 재귀와 같이 시간 복잡도가 큰 알고리즘에서 유용하다.
   >
   > JAVA 알고리즘3에서 설명했기 때문에 간단하게 리뷰만.

   피보나치, 팩토리얼과 같은 함수를 구현할 때 재귀를 사용하면서 계산시간을 줄이기위해 메모이제이션이라는 테크닉을 사용한다.

   이는 계산된 값을 버리지말고 저장한다는 뜻으로 필요할때마다 저장된 값을 사용하며 저장되는 배열을 `캐시`라고 한다.(중간에 저장하는 것을 `캐싱한다`라고 부른다.)

   ![](https://t1.daumcdn.net/cfile/tistory/262CD735593635962F)

2. #### Bottom up

   > 중복된 계산을 피하는 또 다른 방법으로 Bottom up이 있다. 재귀함수가 Top down임에 반해, Bottom p은 f(1)부터 f(n)까지 올라오는 것을 의미한다.
   >
   > 이 방식의 핵심은 아래부터 올라가기 때문에 f(n)을 구하기위해 f(n-1)과 f(n-2)을 계산해야 한다. 따라서 가장 기본적인 값으로 특정한 값을 계산하려고 하는 것을 Bottom up이라고 한다.

   이렇게 `Bottom up`방식으로 계산하는 테크닉을 `Dynamic Programming`이라고 한다. 물론, 이는 다이나믹 프로그래밍을 좁은 의미로 해석할 때 사용하는 방법이지만 가장 많이 사용되는 방법 중에 하나이기도 한다.

   ![](https://t1.daumcdn.net/cfile/tistory/2156E4395936467E1B)

   두번째 예로, `이항계수`를 구하는 알고리즘이다.

   이항 계수는 n개 중에 k개를 선택하는 경우의 수를 구할 때 사용한다.

   보통 `n!/(n-k)!*k!`로 계산을 하지만, 이렇게 할 경우 많은 계산이 중복된다. 또한 계산의 범위가 커질 경우 오버플로우가 생길 수도 있다. 그래서 위의 그림의 공식을 사용하도록 한다.

   물론, n=k일 때나 k=0일 때 1을 반환하도록 한다. 그래서 이를 계산할 때, 재귀코드를 사용해서 계산한다.

   ![](https://t1.daumcdn.net/cfile/tistory/2316FC435936477C01)

   그러나 이와 같은 재귀 계산에도 같은 값에 대해 중복되는 코드가 많아지므로 `메모이제이션`을 사용하면 훨씬 빠른 계산이 가능하다. 앞선 말한 것과 마찬가지로 -1로 모든 캐시 배열을 초기화해주며, -1일 경우 계산을 징행하고, 아닐 경우 해당 인덳의 배열 값을 호출한다.

   ![](https://t1.daumcdn.net/cfile/tistory/27646649593649AB34)

   마찬가지로 이를 `Bottom up`방식으로 계산하면 아래 그림처럼 나온다. 2차원 배열이라 어디가 Bottom up인지 생각할 수 있지만, Bottom up이란 위치가 바닥이 아닌 기본 값에서부터 시작한다는 뜻이된다.

   따라서, 순환식에서 기본 값을 토대로 계속 정답까지 구하므로 재귀가 필요없고 중복 값도 제거된다.

   ![](https://t1.daumcdn.net/cfile/tistory/26419E4D59364A611F)

3. #### Memoization vs. Dynamic Programming

   `Memoization`과 `Dynamic Programming`의 특징은 다음과 같다.

   1. `Memoization`과 `Dynamic Programming`은 둘다 순환식을 계산하는 방법이라고 할 수 있다.
   2. 모두 동적 계획법의 일종이라고 보기도 한다.
   3. `Memoization`은 Top down방식이고 실제 필요한 sub problem을 푼다.
   4. `Dynamic Programming`은 Bottom up방식이며 재귀에 수반되는 overhead가 없다.



### 동적 계획법-2

<https://new93helloworld.tistory.com/221?category=691027>

위와 다른 기본적인 동적 계획법의 예를 알아본다.

순환식을 세우고 이것을 계산하는 과정 전체를 동적 계획법이라고 하며, 동적계획법에서 본질적인 영역은 주어진 문제를 풀기 위한 순환식을 세우는데 있다.

이는 위 링크를 통해 한번 읽어보길 바란다.



### 동적 계획법-3 (분할정복법 vs. 동적계획법)

<https://new93helloworld.tistory.com/223?category=691027>

> 동적 계획법이라는 것은 순환식을 효과적으로 푸는 테그닉으로 순환식과 뗄레야 뗄수 없는 관계이다. 

1. 일반적으로 최적화문제, 카운팅 문제에 적용된다.
2. 주어진 문제에 대한 순환식을 정의한다.
3. 순환식으로 Memoization 또는 Bottom up으로 푼다.

동적 계획법은 subproblem을 풀어서 원래 문제를 푸는 방식이다. 그런 의미에서는 분할 정복법과 공통점이 있다.

다만, 동적계획법은 서로 overlapping하는 subproblem들을 해결함으로써 원래의 문제를 해결하는 것이다.

![](https://t1.daumcdn.net/cfile/tistory/2558F849593A6CF835)

분할 정복법과 동적 계획법의 차이에 대해 알아보자.

분할 정복법의 대표적인 예는 quicksort이다. 퀵 소트의 경우 pivot을 기준으로 두 부분으로 나뉘며, 오른쪽과 왼쪽이 완전히 disjoint하다. 왜냐하면 오른쪽의 계산 결과가 왼쪽에 전혀 영향을 미치지 않기 때문이다. 이렇게 두 개의 subproblem을 해결함으로써 원래 문제가 해결된다.

![](https://t1.daumcdn.net/cfile/tistory/271B5B4D593A6DA72A)

다음은 동적 계획법의 일반적인 행렬 문제이다.

i, j까지 오는 경로를 구할 때 (i-1, j)와 (i, j-1)까지 오는 subproblem들이 구해져야 하는데 이들이 서로 disjoint한 것이 아니라 영향을 미치기 때문에 분할 정복법과는 다른 모습을 보인다.

어떤 문제의 최적해가 그것의 subproblem들의 최적해로부터 효율적으로 구해질 수 있을 때, 그 문제는 optimal substructure를 가진다라고 말한다.

분할 정복법, 탐욕적 기법, 동적 계획법은 모두 문제가 가진 이러한 특성을 이용한다.



![](https://t1.daumcdn.net/cfile/tistory/277A924C593A6EC72F)

따라서 최단 경로문제를 볼 때 어떤 거리까지의 최단 거리의 부분 집합은 항상 최단 거리이기 때문에 결과값을 구하는 순환식은 optimal substructure를 표현하게 된다. 순환식을 세운다는 것은 동적 계획법의 핵심이기 때문에 그리 간단하고 쉽지않다. 그러므로 순환식을 세우는 것에는  스킬이 필요하다.

우선, 내가 지금 구하고자 하는 최적해에 대해서 그 최적해의 일부분이 그 부분의 최적해인가에 대한 질문을 던져야 한다. 이를 기준으로 세우고 식을 점점 발전시킨다면 올바른 순환식이 도출되게 된다.

![](https://t1.daumcdn.net/cfile/tistory/27622E48593A709204)

optimal substructure를 설명하기 위해 다른 예를 보자.

다음은 최장 경로 알고리즘이며, 최단 경로와 반대된 결과를 찾아야한다. 1에서 4까지의 최장 경로는 (1,2,3,4)이지만 1에서 3까지의 최장경로는 (1,4,2,3)이다. 따라서 `최장 경로의 일부분이 그 부분에 대한 최적해다`라는 것이 당연히 성립하지 않는다는 것이다.



![](https://t1.daumcdn.net/cfile/tistory/265A2D4D593A712437)

그러므로 위와 같이 식이 수정되야 한다. S에서 u까지 A에 속한 원소들과 v 모두를 지나지 않고 도달하는 것을 찾고 최대값을 구한다. 최장 경로 문제에 대해서는 `최적해가 그 부분에 해당하는 최적해다`라는 조건이 성립하지 않지만, 이 최장 경로 문제가 optimal substructure가 안되며 동적계획법으로 풀 수 없는 것은 아니다. 왜냐하면 위와 같이 복잡한 형태, 다른 형태의 optimal substructure를 가지기 때문이다.
# JAVA 알고리즘 정리 5

## Sort

### Sort(정렬)

<https://new93helloworld.tistory.com/103?category=691027>

![](https://t1.daumcdn.net/cfile/tistory/2311B244591BA16314)

컴퓨터 알고리즘에 있어서 가장 기본적인 정렬 알고리즘이다.

1. #### 선택정렬

   ![](https://t1.daumcdn.net/cfile/tistory/264E3144591BA1600B)

   이중에서 가장 큰 값을 찾는다. 그 후에 가장 큰 값과 맨 마지막 값의 자리를 바꾼다. 그럼 결과적으로 가장 큰 값이 맨 끝자리로 오게 된다.

   그렇다면 마지막 값에 대해서는 더 이상 신경쓰지 않아도 된다. 이후에 남아있는 4개의 데이터에 대해서 다시 가장 큰 값을 찾아 4번째 위치에 있는 값과 자리를 바꿔준다.

   ```java
   selectionSort(A[], n) {
       for last <- downto 2{
           A[1...last] 중 가장 큰수 A[k]를 찾는다.
           A[k] <-> A[last]; A[k]와 A[last]값을 교환
       }
   }
   ```

   슈도코드로 선택정렬을 나타내면 위와 같다.

   시간 복잡도를 계산하면

   T(n) = (n-1) + (n-2) + ... + 2 + 1 = n(n-1) / 2 = O(n^2)

2. #### 버블정렬

   ![](https://t1.daumcdn.net/cfile/tistory/240D3244591BA16114)

   다음으로는 선택정렬과 기본 개념이 비슷한 버블정렬이다. 즉, 버블 정렬에서도 역시 정렬할 데이터 중 가장 큰 값을 찾아 그것을 맨 마지막자리로 옮겨온 후에 그 데이터는 잊어버리고 나머지 데이터에 대해 같은 작업을 반복한다는 것이다.

   다만, 최대값을 찾아서 그 최대값을 맨 마지막으로 가져오는 세부적인 방법에 대해서 선택정렬과 차이를 보인다.

   ```java
   bubbleSort(A[], n) {
       for last <- downto 2 {
           for i <- 1 to last - 1 {
               if(A[i] > A[i+1]) then A[i] <-> A[i+1] // 교환
           }
       }
   }
   ```

   다음은 슈도 코드로 표현된 버블 정렬이다.

   시간 복잡도는 다음과 같다.

   `T(n) = (n-1) + (n-2) + ... + 2 + 1 = O(n^2)`

3. #### 삽입정렬

   ![](https://t1.daumcdn.net/cfile/tistory/26086944591BA1621E)

   마지막으로 살펴볼 정렬 알고리즘은 `삽입 정렬`로 위의 두 알고리즘과 약간의 차이를 보인다.

   우리가 정렬할 데이터가 6개라면 첫번째 데이터는 데이터가 한개 이므로 그 자체로 정렬되어 있다고 볼 수 있다. 거기에 두번째 데이터를 추가해서 두개의 데이터가 정렬된 상태로 만들어 주는 것이다.

    ![](https://t1.daumcdn.net/cfile/tistory/2505E044591BA16204)

   위의 그림은 삽입정렬이 진행되고 있는 임의의 한 페이즈를 나타낸다. 현재 인덱스의 변수값이 4라고 했을 때 앞쪽의 데이터들은 정렬되어있다고 가정한다. 추가할 데이터 4는 tmp변수에 넣어놓고, 앞쪽의 데이터와 비교하고 앞쪽의 데이터가 크다면 그 데이터를 뒤로 이동시킨다. 만약 tmp안의 변수가 더 크다면 비교한 변수 뒤에 데이터 값을 넣어주게 된다.

   ```java
   insertionSort(A[], n) {
       for i <- 2 to n {
           A[1...i]의 적당한 자리에 A[i]를 삽입한다.
       }
   }
   ```

   슈도코드로 표현한 삽입정렬이다.

   시간 복잡도는 다음과 같다.

   `T(n) = (n-1) + (n-2) + ... + 2 + 1 = O(n^2)`

   ```java
   public static void sort(int[] array) {
       for(int i=1; i<array.length; i++) {
           int temp = array[i];
           int comp = i-1;
           while(comp >= 0 && array[comp] > temp) {
               array[comp+1] = array[comp];
               comp--;
           }
           array[comp+1] = temp;
       }
   }
   ```

   여기서 주목해야 할 점은 while문 내부의 `comp>=0`이다. 등호의 사용해야 배열에 같은 값이 있을 때 이 데이터를 바꾸지 않고 안정한 상태로 유지할 수 있다.


4. #### 합병정렬(Merge Sort)

   합병정렬은 분할정복법이라는 알고리즘을 사용한다. 주어진 문제를 3단계에 걸쳐서 해결하는데 다음과 같다.

   1) 분할: 해결하고 하는 문제를 작은 크기의 동일한 문제로 분할한다.

   2) 정복: 각각의 작은 문제를 해결한다.

   3) 합병: 작은 문제의 해를 합하여 원래 문제에 대한 해를 구함

   분할의 예로써, 입력으로 n개의 데이터가 주어지고 최대값을 찾을 때 배열을 반으로 나누어서 앞쪽과 뒤쪽에서 최대값을 찾고 그 둘 중에 최대값을 찾아 비교하는 절차를 거쳤다. 전체 문제를 해결하는 방법을 각각의 분할된 영역에 그대로 적용할 수 있으므로 별도의 알고리즘이 필요없다.

   분할정복의 풀이는 본질적으로 Recursion의 풀이 방법이다.

   ![](https://t1.daumcdn.net/cfile/tistory/27703A3D591BA46A1D)

   먼저 적당히 데이터를 자르는 분할을 하고 이렇게 분할된 데이터를 재귀로 정렬한다.

   주의해야할 점은 n개의 데이터가 주어질 때 분할하기 위해 특별한 알고리즘이 필요한 것이 아니며 실제로 코딩해야할 것은 `merge`부분이다.

   ![](https://t1.daumcdn.net/cfile/tistory/245FC63D591BA46B24)

   분할을 반복하다보면 마지막은 길이가 하나인 리스트들로 나뉘어진다. 실제로 데이터들이 비교되고 자리를 바꾸는 것은 `merge`과정에서 일어난다. 왜냐면 길이가 1이되면 그 자체로 정렬된 상태이기 때문이다. 

   ![](https://t1.daumcdn.net/cfile/tistory/264F623D591BA46B2A)

   정렬된 2개의 리스트가 있을 때 어떻게 하나의 정렬된 리스트로 합병할 것인지 생각해보면, 길이가 n인 추가 배열을 만든 후에 길이가 n/2인 정렬된 2개의 리스트를 추가 배열에 합병하면 된다.

   단 여기서 주의점은 2개의 리스트가 각각 정렬되어있는 상태라는 ㅓㅅ이다. 이미 정렬이 되어있기 때문에 전체 10개의 값 중에서 가장 작은 값은 앞에서 첫번째거나 뒤쪽에서 첫번째가 가장 작은 값이 된다.

   따라서 병합하며 정렬을 하기 위해서는

   i인덱스에 있는 값과 j인덱스에 있는 값을 하나씩 비교한 후 추가배열에 저장하면 된다.
